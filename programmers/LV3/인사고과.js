/**
 * 규칙
 * 1. 두 점수 둘 다 최고보다 낮으면 못 받음
 * 2. 두 점수의 합이 높은 순서대로 등수 매김
 *
 * 예시
 * [[2,2],[1,4],[3,2],[3,2],[2,1]]
 * 1. 0번째를 일단 shift한다
 * 2. 배열을 두 점수의 합을 기준으로 내림차순으로 sort
 * 3. 원호의 두 점수의 합이 같은 수가 나오는 순간의 둥수를 반환
 *      중간에 원호의 두 점수 모두 작은 순간이 오면 return -1
 *
 * 의심가는 부분?
 * - 합이 같은데 해당 값의 두 숫자가 원호보가 클..리는 없음
 * - 합이 같은데 해당 값이 우연히 원호것보다 앞에 있고, 해당 값이 등수 미달인 경우..
 *      는 안 되는게 원호의 값이 무조건 앞으로 나와서 불가능
 * - 아... 합이 원호 것보다 더 큰데 미달이 사람들이 있구나..
 *     각 요소를 도는데, 각 요소의 합보다 큰 것 중에서 저장할 것을 저장해두는게 좋음
 */
function solution(scores) {
    let answer = 1;
    const [w1, w2] = scores[0];

    scores.sort((a, b) => {
        if (a[0] !== b[0]) return b[0] - a[0];
        return a[1] - b[1];
    });

    let before = 0;
    for (const score of scores) {
        const [s1, s2] = score;
        if (w1 < s1 && w2 < s2) return -1;

        if (before <= s2) {
            if (w1 + w2 < s1 + s2) answer++;
            before = s2;
        }
    }
    return answer;
}

// console.log(
//     solution([
//         [2, 2],
//         [1, 4],
//         [3, 2],
//         [3, 2],
//         [2, 1],
//     ])
// );
// console.log(
//     solution([
//         [2, 1],
//         [1, 4],
//         [3, 2],
//         [3, 2],
//         [2, 1],
//     ])
// );
// console.log(
//     solution([
//         [3, 2],
//         [1, 4],
//         [3, 2],
//         [3, 2],
//         [2, 1],
//     ])
// );

// console.log(
//     solution([
//         [2, 3],
//         [1, 4],
//         [3, 2],
//         [4, 3],
//         [3, 2],
//         [2, 1],
//     ])
// );
