/**
 * 어떻게 풀까?
 * 일단 n2 배열을 만들고 이를 1차원 배열로 만드는 방벙을 생각해보아야 한다.
 *     0  1  2
 * 0 [[1, 2, 3],
 * 1  [2, 2, 3],
 * 2  [3, 3, 3]]
 *
 * n은 3이라고 가정한다
 * [x,y] 라고 했을 때
 * [0,0] => 0
 * [1, 0] [1, 1] [0, 1] => 1
 * [2, 0] [2, 1] [2, 2] [1, 2] [0, 2] => 2
 * 여기서 공통되게 관찰되는 것은, x는 처음에 최대였고 y는 0이었다.
 * y는 점차 커져서 최대가 되고 그 때부터 x가 줄어든다
 * x가 0이 될 때까지 모든 배열인 것이다.
 * -> 이렇게 배열을 만들면 될 듯
 *
 * n2 배열을 만들고 난 후에는 이 것을 1차 배열로 만들면 됨
 * left가 2이고 right가 5이다
 *
 * ---
 * 배열을 그대로 사용하면 배열 크기가 너무 커서 abort가 나온다. 메모리를 너무 많이 사용한 것이다.
 * 배열을 배제하는 방법을 생각해본다.
 *
 * 위 상황에서 답이 [3, 2, 2, 3] 이 나온다. 이 값은 차례대로 [2, 0] [0, 1] [1, 1] [2, 1] 이라는 값이다.
 * 2-> [2, 0] -> 3 // 3 -> [0, 1] -> 2 // 4 -> [1, 1] -> 2 // 5 -> [2, 1] -> 3
 * 눈치를 채자면 num = x + (n * y) 이다!
 * 여기서 x와 y의 값은 나온다. 중요한 것은 배열에서 [x, y] 의 값이 무엇인지 어떻게 아냐는 것이다.
 * 근데 저 예시를 지긋이 쳐다보면 답이 나온다. [x, y]의 값은 x와 y중 최대값에서 1을 더한 것이다...
 */
function solution(n, left, right) {
    return new Array(right - left + 1)
        .fill(0)
        .map((_, idx) => left + idx)
        .map((num) => Math.max(num % n, Math.floor(num / n)) + 1);
}

console.log(solution(3, 2, 5));
console.log(solution(4, 7, 14));
